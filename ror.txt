# Write a program to check weather a number is positive, negative or zero



# def check(number)
    
#     if number > 0
#         puts "positive"
        
#     elsif number == 0
#         puts "zero"
        
#     else 
#     puts "negative"
# end
# end

# check(000000)



# Write a program to reverse a number


# def reverse(number)
#     sum = 0
#      while number != 0
         
#          r = number%10
    
#          sum = (sum * 10 + r)
    
#          number = number /10         
#      end
     
#      puts sum
# end


# reverse(123)


# Write a program to check weather a string is palindrome


# def Palindrom(stringvalue)
    
#     i = 0 
#     j = stringvalue.length-1
    
#     while i <= j
        
#         if(stringvalue[i] != stringvalue[j])
#             puts false
#             return
#         end

#         i += 1
#         j -= 1        
        
#     end
    
#     puts true
# end

# Palindrom("AABBAA")
# Palindrom("AAfgsfdse")



# Write a program for calculator having functionality like addition, subtraction, multiplication,
# division showing remainder and quotient  

# class Calculator
    
#     def additions(value1 , value2)
#         return value1 + value2
#     end
        
#     def subtractions(value1 , value2)
#         return value1 - value2
#     end
        
#     def multiplications(value1 , value2)
#         return value1 * value2
#     end
    
#     def divisions(value1 , value2)
#         y = value1 / value2
#         x = value1 % value2
        
#         return "division quotient include #{y} , division remainder include #{x}"
#     end
    
# end

# calci = Calculator.new()

# puts calci.additions(30 , 10)
# puts calci.subtractions(30 , 10)
# puts calci.multiplications(30 , 10)
# puts calci.divisions(30 , 10)



#  Write a program for table from 2 to 10

# for i in 2..10
    
#     for j in 1..10
#         puts ("#{i} * #{j} = #{i*j}")
#     end
    
# end


# Write a program to find minimum and maximum between two number

# def MINMAX(value1 , value2)
    
#     if value1 > value2
#         return "value1 i.e #{value1} is maximum"
        
#     elsif value2 > value1
#         return "value2 i.e #{value2} is maximum"
#     end
    
# end


# puts MINMAX(207 , 33)


#  Write a program to find square root of a number given by user


# number = 100

# sqrtno = Math.sqrt(number)

# puts sqrtno


# Write a program to find square and cube of a number given by a user


# class Operations
    
#     def initialize(number)
#         @number = number                 # for instance variable we always use @sign
#     end
    
#     def square
#         return @number*@number
#     end
    
#     def cube
#         return @number**3
#     end

# end

# # values = operations(8)

# operationsValues = Operations.new(8)

# puts operationsValues.square
# puts operationsValues.cube



# Write a program to find minimum and maximum in an array


# arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]

# small = arr[0]
# big = arr[0]

# arr.each do |numbers|
    
#     if small > numbers
#         small = numbers
#         elsif big < numbers
#             big = numbers
#         end
#     end
        
# puts small , big
        
        
# Write a program to find even and odd number in an array

# def calculate(number)
    
#     if number %2 == 0
#         return "even"
#     else return "odd"
#     end
# end

# puts calculate(3)
        
  
# Write a program to find even numbers between 1 to 100

#   for i in 1..100
      
#       if i %2 == 0

#       puts i
#   end

# end        
        

#   Write a program to find odd numbers between 1 to 100

#   for i in 1..100
      
#       if i %2 != 0

#       puts i
#   end

# end      



# Write a program to find factorial of a number enter by user


# def Factorial(number)
    
#     x = 1
#     while number != 0
        
#         x = x * number
#         number = number-1
#     end

# puts x

# end


# Factorial(13)


# Write a program to find sum of digits of a number


# sum = 0
# for i in 1..120
    
#     sum = sum + i
    
# end

# puts sum



# Write a program to find a number is prime or not given by user

# def CheckPrime(number)
    
#     for i in 2..number/2

#       if number % i == 0
        
#         return "not a prime no."
        
#     end
# end

# return "Its a prime no."

# end

# puts CheckPrime(65)



# Write a program to reverse a string given by user

# def reversee(stringvalue)
    
#     x = 0
#     y = stringvalue.length-1        # remember always initiallize values on a diffenent different lines not in one lines
    
#     while x <= y
        
#         temp = stringvalue[x]
#         stringvalue[x] = stringvalue[y]
#         stringvalue[y] = temp
        
#         x = x+1
#         y = y-1
#     end
    
    
#     puts stringvalue

# end

# reversee("chirag")


# Write a program to remove spaces from a string given by user


# def RemoveSpaces( stringValues )
    
#     astr = ""
    
#     stringValues.each_char do |char|                     # for accessing particular character we use .each_char
         
#         if char == " "
#             next
#         elsif astr = astr + char
            
#         end
# end 

# puts astr
# end

# RemoveSpaces("Removc eSpaces djaslhlajoahe")




# Write a program to print pyramid using *
# Note print doesn't go to next line after printing puts 
# goes to next line after printing only puts act's as cout<<endl;

# 5.downto(i)  this line countss in descending order from 5 to i 

# for i in 1..5
    
#     for j in 5.downto(i)
        
#         print " "
#     end

#     for k in 1..(2*i-1)
        
#         print "*"
#     end
#     puts

# end




# Write a program to print inverted pyarmid using *

# for i in 1..5

#   for j in 1..i

#     print " "
    
# end

#  for k in 9.downto(2*i-1)
     
#      print "*"
     
# end

# puts

# end    






# Write a program to sort an array in assecending order

# arr = [2,5,7,4,3,26,7,8]


# for i in 0..arr.length-1

#     for j in i+1..arr.length-1

#       if arr[i] > arr[j]
           
#           temp = arr[j]
#           arr[j] = arr[i]
#           arr[i] = temp
#       end
#   end
# end


# puts arr          # shows every element line by line 
# print arr         # shows every element in single line
    
    
    
    
#  Write a program to find number of vowel in a string


# def vowels(strr)
#     count = 0
    
#      for i in 0..strr.length-1
         
#          if strr[i] == 'a' || strr[i] == 'e' || strr[i] == 'i' || strr[i] == 'o' || strr[i] == 'u' ||
#              strr[i] == 'A' || strr[i] == 'E' || strr[i] == 'I' || strr[i] == 'O' || strr[i] == 'U'  

#          count += 1
#      end
#     end
    
#     print count

# end

# vowels("akhkawkahwebJRLGALALDGALDHGLASHDFL;IAHDLHASDL;HLWEjfiaejrgioharoighaoeirhgoiehrgo;ihawe")




# Write a program to find number of constant in a string
    
    
# def vowels(strr)
#     count = 0
    
#      for i in 0..strr.length-1
         
#          if strr[i] == 'a' || strr[i] == 'e' || strr[i] == 'i' || strr[i] == 'o' || strr[i] == 'u' ||
#              strr[i] == 'A' || strr[i] == 'E' || strr[i] == 'I' || strr[i] == 'O' || strr[i] == 'U'  

#          next
         
#      elsif strr[i] > "A" && strr[i] <= "Z" || strr[i] > "a" && strr[i] <= "z"
#           count +=1
#      end
     
#     end
    
#     print count

# end

# vowels("aeioubnmgughjetd")




# Write a program to count all alphabet in a string

   
#     def vowels(strr)
#     count = 0
    
#      for i in 0..strr.length-1
         
#          if strr[i] >= 'a' && strr[i] <= 'z' || strr[i] >= "A" && strr[i] <= "Z"
#              count += 1
#      end
     
#     end
    
#     print count

# end

# vowels("adsfchbngj8294:::")



# Write a program to add & subtract 10 days in a date

# require 'date'

# day = Date.today - 10

# puts day


# add and subtract one year from a Date

# require 'date'

# day = Date.today - 365

# puts day



#  add and subtract one month from a Date
    
# require 'date'

# day = Date.today - 30

# puts day


# classses and its types 

# a = 100

# puts a                # 100

# b =  a.class  

# puts b                # integer

# c = b.class

# puts c.class          # class



# class Monitor 

#   def webkorps(value1 , value2)
    
#      puts value1 , value2
#       puts "Its a method of class monitor"
    
#      return "Hello brother"
   
#  end
#  end


#  class Student < Monitor
   
#     def webkorps(a , b)
#         super
#         puts "Its a method of webkorps monitor"
        
#         return super + " my name is chirag"
#     end
# end 


# puts Student.new.webkorps(3 , 9);

# monitor = Monitor.new()

# monitor.webkorps(4 ,8)


# output
# 3
# 9
# Its a method of class monitor
# Its a method of webkorps monitor
# 3
# 9
# Its a method of class monitor
# Hello brother my name is chirag
# 4
# 8
# Its a method of class monitor
  

# def monitor()
          
#     arr = [1,2,3,4,5,6]
#     arr1 = []
#     i = arr.length-1 
#     k = 0
  
#     for i in 0.downto(arr.length-1)
     
#       arr1[k] = arr[i]
#       k++
     
#     end
#   print arr1      
# end

# monitor()













# Types of variable *********************************************************************************

# 5. Variables
# Local variables: name
# Instance variables: @name
# Class variables: @@name
# Global variables: $name

# local variable

# def greetings(name)
#     message = "Hello #{name}"
#     puts message
# end

# greetings("Rohit") # Output: Hello Rohit


# Instance variable

# class Person
#     def initialize(name)
#         @name = name
#     end

#     def greetings
#         puts "Hello #{@name}"
#     end
# end

# person = Person.new("Rohit")
# per son.greetings # Output: Hello Rohit


# class variable

# class Webkorps
    
#     @@count = 0
    
#     def initialize(name)
        
#         @name = name
#         @@count += 1
#     end
    
#     def self.count
#         @@count
#     end
# end

# w1 = Webkorps.new("Chirag")
# w2 = Webkorps.new("varun")


# puts Webkorps.count            # output 2


# global variable

# $counttt
# class Webkorps
    
#     @@count = 0
    
#     def initialize(name)
        
#         @name = name
#         @@count += 1
#         $counttt = @@count
#     end
    
#     # def self.count
#     #     @@count
#     # end
# end

# w1 = Webkorps.new("Chirag")
# w2 = Webkorps.new("varun")


# puts $counttt              # output 2







# shortcut of loop i.e timesloop

# 5.times { |i| puts i }




# Blocks are chunks of code which we right inside {} or do..end that can be passed to a method
# to be executed 

# [1,2,2,3].each do |nums|
#      puts nums
#      end

# or 

# [1,2,33,4].each {|nums| puts nums}


# In the examples above, |num| are block variables, which are placeholders for the values passed into the block.


# yield keyword in ruby******************************************************************************

# used to stop execution of a method and call a block first
# When a method contains yield, it pauses at that point, and the block of code passed to it is executed. After the block finishes, the method continues running.



# def webkorps 
    
#     puts "Hello mere bhai"
    
#     yield
    
#     print "bro how are you"
#     puts
    
# end

# webkorps {puts "kaisa hai tu"}       


# o/p ->  Hello mere bahi    1st its print and then stop execution and block execution is start and then method continue 
# kaisa hai tu
# bro how are you



# Procs*********************************************************************************************

# A proc is like a block, but it's an object, so you can save it to a variable and reuse it.
# You can pass a proc to a method as an argument.
# Procs are created using Proc.new or the proc method.



# my_proc = Proc.new {puts "Hello from proc"}   # Here capital P is there 

# my_proc.call                    #.call used to call proc , block and lambda           # output Hello from proc


# my_proc = proc {puts "Hello from proc"}           # Here small p is there

# my_proc.call                  # output hello from proc



# def greet(prroc)
    
#      prroc.call
# end

# greet(my_Proc)

# output
# "Hello from proc
# Hello from proc



# procs with different ways

# my_Proc = proc {|name| puts "Hello baby my name is #{name}"}

# my_Proc.call("varun")
# my_Proc.call("Chirag")




# Difference between blocks and procs *********************************************

# Blocks: Simple, can't be stored, and only one per method.
# Procs: Flexible, can be stored in variables, and passed as many times as needed.


# how we can pass block as an argument

# class Greetings
    
#     def greet(name , &block)       #&block reserve keyword used to take block as an argument
        
#         puts  "Hello from #{name}"
        
#         if block_given?        #block_given?  reserve keyword used to check weather
#                                # block passed in a method or not
#             block.call(name)   # its calls the block which is initialize below
#         else
            
#            puts "Hello from greet"
#        end
# end        
    
# end

# greettt = Greetings.new

# greettt.greet("Alice") do |name|       # here we are calling greet method with name and object both 
    
# puts "Hello brother my name is #{name}"
    
# end

# greettt.greet("bob")    # here we calling greet only with name


# output
# Hello from Alice
# Hello brther my name is Alice
# Hello from bob
# Hello from greet


# 2nd way of passing block inside a method 

# class Parent
#   def process(&block)
#     block.call if block_given?
#   end
# end

# class Child < Parent
#   def process(&block)
#     puts "Processing in Child"
#     super
#   end
# end

# child = Child.new
# child.process { puts "Processing in Block" }


# output

# Processing in Child
# Processing in Block




# Lamdbas *****************************************************************************************

# When it comes to encapsulating code into reusable units, lambdas are similar to procs.
#  However, in terms of behavior and syntax, they do differ slightly from one another.
# The main difference lies in argument handling and return statements.


# What are lambdas?
# Lambdas are anonymous functions that can be assigned to variables or passed as arguments.
#  The lambda keyword or the -> syntax is used to define lambdas in Ruby, and behave like methods. 
#  They can be considered as an advanced version of procs.



# my_lambda = lambda { |x, y| puts x+y}  #using lambda keyword

# my_lambda = ->(x , y) {puts x + y}    #using -> syntax



# The main difference between lambdas and procs lies in how they handle return statements and argument checking.
# Lambdas perform argument checking, ensuring that correct number of arguments are passed.
# Additionally, lambdas return control to the calling method, whereas procs return immediately, bypassing the calling method


# difference between proc and lambda

# Procs: return exits both the Proc and the method that called it.
# Lambdas: return exits only the lambda, allowing the method that called the lambda to continue executing.


# proc example 

# def proc_example
#   my_proc = Proc.new do
#     puts "Inside Proc"
#     return "Returning from Proc"
#   end
  
#   result = my_proc.call
#   puts "This line will not be executed."    # because return inside proc return immediately that's why method ends its execution
#   return result
# end

# puts proc_example

# output
# Inside Proc
# Returning from Proc

# lambda example 


# def lammm
    
#     my_lambda = lambda do 
        
#         puts "HEllo bro from lambda"
        
#         return "return from lambda"
#     end
    
    
#     result = my_lambda.call
    
#     puts "this line is executed"   # here it work because return inside lambda didn't return immediately it's return statement didn't stop execution of method it's stop execution of only lambda
    
#     return result
# end

# puts lammm

# output
# HEllo bro from lambda
# this line is executed
# return from lambda




# increment_and_double = ->(num) { (num+1) *2}

# result = increment_and_double.call(5)
# puts "Result = #{result}"


# Notes for procs and lambdas


# Conclusion

# Ruby provides a means to organize statements into blocks of code that can be performed and supplied
#  to functions.

# It is possible to save, call, and send code blocks as parameters to methods by enclosing 
# them in objects called procs in Ruby.

# Using the call method, procs can be called and reused because they can be assigned to variables, 
# making them callable.

# Procs can be supplied to methods as arguments, giving a mechanism to transmit both behavior
#  and data and increasing the flexibility of the code.

# Although lambdas and procs are similar, they differ slightly in their syntax and behavior,
#  including strict parameter checking and method-like return statements.

# Closures, including lambdas and procs, can return values to the calling context using the 
# return keyword, facilitating data exchange between closures and their callers.




# closures*************************************************************************************

# so yield call backs to greeter function and pass greeting  


# Block(Closure): The block { |greet| puts greet + ", World!" } is a closure because it captures 
# the greeting variable from the method's scope and can use it when executed.
 
# def greeter
     
# greeting = "hello"
# yield(greeting)

# end

# greeter do |greet|
# puts greet + ", World!"
# end

# output
# Hello world



# def create_closure
     
# message = "Hello from create closure"

# proc = Proc.new do              # a new proc object which is a closure is created . This proc capture the message variable
#     puts message
# end


# return proc
# end

# create_closure.call

# Output : Hello from create closure

# Closures are blocks, procs, or lambdas that capture the variables from their surrounding context
# (the environment where they were defined).


# They allow you to "freeze" the environment and use it later, even if the environment 
# where the closure was created no longer exists.


# def make_multiplier(factor)
#   # `factor` is a variable in the scope of this method
#   Proc.new do |number|
#     number * factor
#   end
# end

# multiplier_by_3 = make_multiplier(3)
# multiplier_by_5 = make_multiplier(5)

# puts multiplier_by_3.call(10)  # Outputs: 30
# puts multiplier_by_5.call(10)  # Outputs: 50






# SELF keyword ************************************************************************************

# class Webkorps
    
#     def initialize(name)
#         @name = name
#     end
    
#     def crook
#         puts "my name is #{@name}"
        
#         puts "Hello this is from self #{self}"
#     end
    
# end

# obj1 =  Webkorps.new("Chirag")
# obj2 =  Webkorps.new("varun")

# obj1.crook
# obj2.crook

# output 
# my name is Chirag
# Hello this is from self #<Webkorps:0x00005796ef041608>  # hexadecimal code with class name
# my name is varun
# Hello this is from self #<Webkorps:0x00005796ef0414c8>


# here we creating class method i.e. threw self no need to create object when creating method threw self because it's belongs to class method

# class Webkorps
#   def self.greet
#     puts "Hello from the Webkorps class!"
#   end
# end

# Webkorps.greet

# Output:
# Hello from the Webkorps class!




# self is class method when you use self in a class self refer to the class not an instance of a class

# class Webkorps
    
#     def self.discreate           # it's a class method or we can say it's a singleton method 
        
#         puts "Hello from class self #{self}"
#     end
    
# end


# Webkorps.discreate     # it shows the output i.e. Helllo from class self Webkorps




# self used to access instance variable 

# class Webkorps
    
#     def initialize(name)
#         self.name = name                # here self.name= name calling a setter method i.e. name= 
#     end
    
#     def name=(name)                     # this is setter method i.e name=
       
#         @name = name.capitalize            # capitalize used to make first letter of name capital
#     end
    
#     def self_name
#         puts "my name is #{@name}"
   
#    end
# end

# web = Webkorps.new("chirag")
# web.self_name



# self one more e.g

# class Example
#     def self.func
#         puts self.class # Output: class
#     end
# end
  
# Example.func


# an if you see this

# class Example
#     def func
#         puts self.class # Output: Example
#     end
# end
  
# example = Example.new
# example.func



# self Inside of a Class or Module Definition********************************************************

# Within a class or module definition, self refers to the class or module itself.
#  It allows us to define methods and access class-level variables directly 
#  without the need for a method call.

# No need for method or class call 

# module Webkorps
    
#     puts self       # output Webkorps
    
#     class Employee
#         puts self       #  output Webkorps :: Employee
#     end
    
# end



# Summary:

# self in Instance Methods: Refers to the instance of the class that called the method.
# self in Class Methods: Refers to the class itself.
# Using self to Define Class Methods: You can define a class method using self.method_name.
# Using self to Access Instance Variables: Allows you to call instance methods like setters 
# within other instance methods.




# conclusion
# The self variable in Ruby refers to the current object and its behavior depends on the context.

# In a class method, self refers to the class itself. It can be used to define class-level variables
# #  or methods.

# In an instance method, self refers to the instance of the class on which the process is called.
#  It allows accessing and modifying instance-specific data.

# Within a class or module definition, self refers to the class or module itself.
#  It is used to define class/module-level methods and variables.


# Singleton method **********************************************************************************

# we can create only one function threw one object that why it's name is a singleton method
# class Webkorps 
#     puts "Hello #{self}"
#     end
    
#     w1 = Webkorps.new
     
#    def w1.func                 # here we are creating threw object memory address 
       
#        puts "hello #{self}"
#    end
   
   
#    w1.func

#   output
# Hello Webkorps
# hello #<Webkorps:0x000064904e064080>       this is object memory address which tells that object is of webkorps class and after that hexadecimal memmory address


# conclusion

# In a singleton method, self refers to the singleton object on which the method is defined.
#  Singleton methods are defined on specific instances rather than on the class itself.
# Understanding the different contexts of self is crucial for writing clean and efficient Ruby code as it enables proper utilization of object-oriented concepts and encapsulation.
# By using self-effectively, developers can manipulate and access data at the appropriate level of abstraction, resulting in more maintainable and organized code.





# super keyword *************************************************************************************

# with arguments
# class Parent
    
#     def initialize(name)
#         @name = name
#     end
# end

# class Child < Parent
    
#     def initialize(name , age)
#         super(name)
#         @age = age
        
#         puts "#{@name}"
#         puts @age
#     end
# end

# childObject = Child.new("Chirag" , 29)



# super keyword without arguments


# no need for an argument to be called threw super class it's automaticallly 
# send child class arguments to base class



# class Parent
    
#     def valueChange(name , age)
#       namevalue = name
#       agevalue = age
       
#       print namevalue ," ", agevalue
#     end
# end

# class Child < Parent
    
#     def valueChange(name , age)
#         super
#     end
# end

# childObject = Child.new

# childObject.valueChange("Chirag" , 29)



# DIffernce between super and super()

# class Parent
#   def foo
#     "Hello from Parent"
#   end

#   def bar(name)
#     "Hello, #{name} from Parent"
#   end
# end

# class Child < Parent
#   def foo
#     super
#   end

#   def bar(name)
#     super()               #always call superclass method without arguments
#   end
# end

# child = Child.new
# puts child.foo # Output: "Hello from Parent"
# puts child.bar("Rahul") # Output: "ERROR"   because when super()  means we call s
# uperclass method without passing any argument even if child class sending 
# any parameter then also super()  didn't call parent with arguments it's always 
# call without arguments 




# exception handling 


# 1st way
# def calculate(a , b)
    
#     begin
    
#     c = a/b
    
#     puts c
    
#    rescue ZeroDivisionError
       
#     puts "caught an exception "
#    end

# end


# calculate(3 , 0)

# 2ND WAY
# def calculate(a , b)
    
#     begin
    
#     c = a/b
    
#     puts c
    
#    rescue ZeroDivisionError
       
#     puts "caught an exception i.e. can't divide by zero"
#    end

# end


# calculate(3 , 0)

# one more way 

# class Parent

#     def foo

#     raise "hello from parent exception"
# end

# end


# class Child < Parent
    
#     def foo
        
#     super 
    
#     puts "this line won't executed because threw super already an exception raise successfully"
    
#     rescue => e
    
#     puts "exception in this code #{e.message}"
    
# end

# end

# child = Child.new

# child.foo            # output exception is this code ---




# super with multiple ancestor or we can say in multilevel inheritance 

# class Grandparent
#   def foo
#     "Hello from Grandparent"
#   end
# end

# class Parent < Grandparent
#   def foo
#     super
#   end
# end

# class Child < Parent
#   def foo
#     super
#   end
# end

# child = Child.new
# puts child.foo




# getter and setter ****************************************************************************


# class Webkorps
    
#     attr_accessor :name
    
#     def initialize(name)
#         @name = name
#     end
    
# end

# objext = Webkorps.new("Chirag")

# puts objext.name    # getter 

# objext.name = "alice"


# puts objext.name     # setter


# getter setter second example 



# # class Webkorps
    
# attr_accessor :name    #getter and setter
    
# def name=(value)
    
#     @name = value.capitalize
    
# end

# end

# class Child < Webkorps

# def name=(value)
    
#     super(value)
    
#     puts "Name has been set in the Child class"
    
# end
# end

# objext = Child.new

# objext.name = "john"    # getter 

# puts objext.name

# # objext.name = "alice"

# puts objext.name     # setter



# Files I/O

# replace all things of files threw this two line written below

# File.open("example.txt" , "w") do |file|
#   file.puts "Hello world!"
#   file.puts "This is a file operation in ruby"

# end


# read line by line
# File.open("example.txt" , "r") do |file|
  
#   file.each_line do |line|
#     puts line
#   end

# end

# # appending in a file 

# File.open("example.txt" , "a") do |file|

#   file.puts "This is a file operation append operatinons ruby"

# end

# # r+ shows read and wright 
# File.open("example.txt", "r+") do |file|
#   puts file.read  # Reads the content
#   file.write "Adding new content."  # Writes new content at the end
# end


# # W+ shows  wright and read

# File.open("example.txt", "w+") do |file|
#   file.puts "New content, overwriting the file."
#   file.seek(0)  # Move the file pointer to the beginning
#   puts file.read  # Reads the new content
# end

# # a+ append and read mode

# File.open("example.txt", "a+") do |file|
#   file.puts "Appending this line."
#   file.seek(0)  # Move the file pointer to the beginning
#   puts file.read  # Reads the entire file, including the new content
# end


# # read entire file

# File.open("example.txt", "r") do |file|
#   content = file.read
#   puts content
# end


# # file size

# puts File.size("example.txt")  # Outputs the size of the file in bytes



# # checkking existing file

# if File.exist?("example.txt")
#   puts "File exists."
# else
#   puts "File does not exist."
# end


# Summary:
# Modes: "w", "r", "a", "r+", "w+", "a+".
# Operations: Reading, writing, appending, checking file size, and file existence.
# Examples: Provided for each mode to illustrate typical use cases.




# regualar expression ********************************************************************************

# Regular Expressions are used for matching patterns within strings.

# Ruby provides a powerful set of tools to create and use regex.

# Common methods: =~, .match, .gsub, .scan, etc.

# Application in RoR: Often used in validations, text processing, and data extraction.



# if "hello world" =~ /world/
    
#     puts "found"
    
# else 
#     puts "not found"
# end

# output found


# for case sensitive 

# if "hello World" =~ /world/i
    
#     puts "found"
    
# else 
#     puts "not found"
# end

# found


# matching email formate 

# email = "chirag@gmail.com"

# if email =~ /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
    
#     print "match with email formate"
#     puts
    
# else 
#     puts "not match with email formate"
    
# end



# gsub!  used to replce text

# text = "I love dhruvi"

# text.gsub!("dhruvi" , "anushka")

# puts text


# one more ways of using regular expressin i.e. regex


# (\d+) captures a sequence of digits, and $1 refers to the first captured group (in this case, "123")

# price = "price : $12345"

# if price =~ /price : \$(\d+)/
    
#     puts "the price is #{$1}"       
# end


# output the price is 12345


# scan method

# text = "Cats are cute. Cats are fun."
# matches = text.scan(/Cats/)

# puts matches.inspect  # Outputs: ["Cats", "Cats"]



# Multi threading**************************************************************************************



# Multithreading is a crucial concept in programming that enables the execution of multiple tasks
# concurrently, thereby improving the performance and responsiveness of applications.
# In Ruby, the Thread class provides native support for multithreading,
# allowing developers to leverage the benefits of parallel execution.
# This article aims to delve into the effective usage of Ruby threads,
# providing insights into their creation, termination, lifecycle, exception handling,
# and various other aspects.

# Developers can use Ruby threads to build applications that can handle multiple tasks simultaneously. 
# This is particularly advantageous for tasks that require significant computational power, 
# involve I/O operations, or benefit from concurrent execution for improved performance. 
# Ruby threads provide a higher-level abstraction, making it easier to implement concurrent 
# behaviour and simplifying the development of multi-threaded programs.


# e.g. 1

# thread = Thread.new do                 # thread.new keyword is used to create thread
#     puts "helllo woldsdgsdf"
# end


# thread.join                           # join keyword is generally used to access thread


# e.g.2

# th1 = Thread.new do 
#     puts "From th1"
# end

# th2 = Thread.new do
#     puts "From th2"
# end

# th1.join
# th2.join

# output  From th1
        # From th2




# Terminating ruby thread 
# Threads in Ruby are terminated automatically when the code within the thread block completes.
#  However, there might be cases where you need to explicitly terminate a thread.
#   The Thread#kill method can be used to forcefully terminate a thread.

# e.g.3

# thread = Thread.new do 
#    puts "hello world"
#    end


# thread.kill
# thread.join
# output   #              -> blank because we kill the thread now after that no sense of join




# Thread Lifecycle


# The lifecycle of a Ruby thread involves the creation, execution, and termination stages.
# During creation, a thread is instantiated using Thread.new and enters the runnable state.
# In the execution stage, the thread actively runs and performs tasks concurrently with other threads.
# It can be paused using Thread#sleep and resumed later. Finally, the thread terminates either 
# by completing its execution or being explicitly terminated using Thread#kill. 
# Managing the thread lifecycle requires synchronization and proper resource management 
# for the stability and integrity of the application.


# Threads and Exceptions

# Thread.abort_on_exception = true    
# If you have a multi-threaded application where a failure in any thread indicates a serious problem 
# that should cause the entire program to halt, setting abort_on_exception to true ensures that such 
# failures are not silently ignored. It forces the application to stop,
#  which might be necessary if the error in one thread compromises the integrity of the
#   entire application.



# Thread.abort_on_exception = true              #

# th = Thread.new do
#     # Thread code goes here
#     raise "Exception raised"
# end

# # ...

# begin
#     th.join
# rescue => e
#     puts "Exception caught: #{e.message}"
# end

# Output => Exception caught: Exception raised




# Thread Pools


# Thread Pool is an abstraction that allows us to assign a task to a pool of threads,
# where one of the available threads will execute the task. Thread pools are beneficial in scenarios
# where the overhead of creating and destroying threads is a concern. By creating a pool of reusable 
# worker threads and reusing them for different tasks, the performance of long-running applications, 
# such as services, can be significantly improved.

# The concurrent-ruby gem provides higher-level abstractions in addition to thread pools.
# Thread pools are referred to as 'executors'. An executor is an object that can accept a unit of
# work and execute it. Thread pools are the primary type of executor we will encounter, with other
# types primarily used for testing or unusual edge cases.

# Here is an example of using a thread pool executor:


# require 'concurrent'

# th_pool = Concurrent::ThreadPoolExecutor.new(min_threads: 5, max_threads: 5)

# 5.times do |i|
#     th_pool.post do
#         puts "Task #{i} executed by thread #{Thread.current.object_id}"
#     end
# end

# th_pool.shutdown
# th_pool.wait_for_termination




# Thread Variables

# Ruby threads have thread-local variables that can be used to store and access data specific
# to each thread. Thread-local variables are isolated and not shared among threads.
# To define and access thread-local variables, we can use the Thread.current object.


# th = Thread.new do
#     Thread.current[:greet] = "Hello"
#     puts Thread.current[:greet]
# end

# th.join        # output hello



# Thread priority


# Ruby threads have a concept of priority that can be used to influence their scheduling. 
# The default thread priority is 0. Higher-priority threads are given preference by the Ruby 
# interpreter during scheduling. To set the priority of a thread, 
# we can use the Thread#priority= method.

# Here's an example:

# th = Thread.new do
#     # code
# end

# th.priority = 2




# Thread exclusion

# often referred to as mutual exclusion, is a concept used to prevent multiple threads 
# from accessing shared resources at the same time. This is important because if multiple threads 
# try to modify the same resource (like a variable or file) simultaneously, it can lead to 
# unpredictable results, such as data corruption or incorrect calculations.


# Imagine two threads trying to increment the same counter variable at the same time. 
# Without thread exclusion, both threads might read the current value of the counter at the same time, 
# increment it, and then write the new value back. If the initial value was 5, you might expect the 
# final value to be 7 after both threads run, but due to the race condition, the final value might 
# still be 6.


# require 'concurrent'

# mutex = Mutex.new
# counter = 0

# # Create a thread pool with 5 threads
# th_pool = Concurrent::ThreadPoolExecutor.new(min_threads: 5, max_threads: 5)

# 10.times do
#   th_pool.post do
#     mutex.synchronize do
#       # Only one thread can enter this block at a time
#       temp = counter
#       temp += 1
#       counter = temp
#     end
#   end
# end

# th_pool.shutdown
# th_pool.wait_for_termination

# puts "Final counter value: #{counter}"




# Handling Deadlock

# Deadlock is a situation where two or more threads are blocked indefinitely, waiting for each other 
# to release resources. Deadlocks can occur when threads acquire locks in different orders, 
# leading to a circular dependency. To avoid deadlocks, it's essential to carefully design our 
# multithreaded code and ensure that locks are acquired in a consistent order.

# Here are some general guidelines to prevent deadlocks:

# Always acquire locks in the same order across all threads.
# Use timeouts when acquiring locks to prevent indefinite waiting.
# Use thread-safe data structures and libraries to minimize the need for manual synchronization




# Module and Mixins***********************************************************************************


# What is a Module?
# A module in Ruby is a collection of methods, constants, and other module or class definitions. 
# Modules are similar to classes, but they cannot be instantiated (you can't create objects from them).
# They are mainly used to group related methods together and to share code between classes.



# What is a Mixin?

# A mixin is a way to add functionality from a module to a class. When a module is included in a 
# class, the methods from the module become available as instance methods of that class. 
# This is the essence of a mixin in Ruby.


# Inculding a module

# When you include a module in a class, the methods defined in the module become instance methods 
# of the class. This means that objects (instances) of the class can use those methods.


# module Parent
    
#     puts "Hello from parent"
    
#     def Child
#         puts "helllo from child"
#     end
    
# end

# class Child2
        
#    include Parent   
#    puts "hello"

# end
    

# children = Child2.new

# children.Child

# output
# Hello from parent
# hello
# helllo from child



# extending a module in mixins

# When you extend a module in a class, the methods defined in the module become class methods of that 
# class. This means you can call those methods directly on the class itself, rather than on an 
# instance of the class.


# module Parent
    
#     puts "Hello from parent"
    
#     def Child
#         puts "helllo from child"
#     end
    
# end

#     class Child2
        
#         extend Parent
        
#         puts "hello"
#     end
    


# Child2.Child                   # in extend we don't need to create instance i.e. object of a class

# output
# Hello from parent
# hello
# helllo from child



# one more e.g

# module A
#   def hello
#     puts "Hello from module A!"
#   end
# end

# module B
#   def hello
#     puts "Hello from module B!"
#   end
# end

# class MyClass
#   include A
#   include B
# end

# obj = MyClass.new
# obj.hello                 # ouptput is Hello from module B!

# Since B was included after A, its hello method is found first.



# # What is a Hash?***********************************************************************************

# In Ruby and Ruby on Rails (RoR), a hash is a collection of key-value pairs, like a dictionary.
#  You use keys to look up values. It’s a bit like an address book where you can look up a person’s
#   address (the value) using their name (the key).





# Person = {
#         Name: "CHirag Agrawal",
#         City: "Chhindwara",
#         Age:  23
#     }
    
    
    # puts Person[:Name]
    
    # puts Person[:Age]
    
    # Person[:gender] = "Male"
    
    # puts Person[:gender]
    
    # puts Person.keys
    
    # puts Person.values
    
    
    # Person.each do |key , value|
    #     puts "keys : #{key} , values : #{value}"
    # end
    
    
    
    # Person.delete(:City)
    
    # puts Person[:City]               #output : blank
    
    
    
#     puts Person.has_key?(:Name)
#     puts Person.value?("CHirag Agrawal")
    
    
    
# Ranges 

# represent with 2 and three dot's i.e. 1..5 in which 1 to 5
# where both included and 1...5 here in three dot's 5 excluded
    
# to_a convert range of all elements into an array of a series

# range_array = (1..5).to_a
# puts range_array.inspect  # Outputs: [1, 2, 3, 4, 5]




# Map method ***************************************************************************************


# hash = {
#     "key1": 1,
#     "key2": 2,
#     "key3": 3
# }


# transformed_hash = hash.map{ |key , value| [key , value*2]}.to_h

# puts transformed_hash

# How to Use Map with an Index?


# Cities = ["mumbai" , "delhi" , "kolkata"]

# IndexCities = Cities.map.with_index {|item , index| "#{item} , #{index}"}

# puts IndexCities

# shorthand notations used to convert each values into string

# numbers = [1, 4, 7]


# str_num = numbers.map(&:to_s)

# print str_num                             #["1", "4", "7"]



# Map vs each method


# The map and each method are both used to traverse collections in Ruby, but they have different purposes.

# Each method simply iterates over a collection and operates on each element. The return value of each method is the original collection.

# The map method, on the other hand, iterates over a collection and transforms each element of the collection using a block of code. The return value of the map method is a new collection with the transformed data.




# arr = ["scaler", "academy", "interview bit"]

# a = arr.each { |element| element.capitalize }
# puts a     # ["scaler", "academy", "interviewbit"]

# b = arr.map { |element| element.capitalize }
# puts b     # ["Scaler", "Academy", "Interviewbit"]




# one more e.g

# arr = [1, 2, 3]
# squared = arr.map { |n| n * n }
# puts squared.inspect  # Outputs: [1, 4, 9]















    
    
    


