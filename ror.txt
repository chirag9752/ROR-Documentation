# Write a program to check weather a number is positive, negative or zero



# def check(number)
    
#     if number > 0
#         puts "positive"
        
#     elsif number == 0
#         puts "zero"
        
#     else 
#     puts "negative"
# end
# end

# check(000000)



# Write a program to reverse a number


# def reverse(number)
#     sum = 0
#      while number != 0
         
#          r = number%10
    
#          sum = (sum * 10 + r)
    
#          number = number /10         
#      end
     
#      puts sum
# end


# reverse(123)


# Write a program to check weather a string is palindrome


# def Palindrom(stringvalue)
    
#     i = 0 
#     j = stringvalue.length-1
    
#     while i <= j
        
#         if(stringvalue[i] != stringvalue[j])
#             puts false
#             return
#         end

#         i += 1
#         j -= 1        
        
#     end
    
#     puts true
# end

# Palindrom("AABBAA")
# Palindrom("AAfgsfdse")



# Write a program for calculator having functionality like addition, subtraction, multiplication,
# division showing remainder and quotient  

# class Calculator
    
#     def additions(value1 , value2)
#         return value1 + value2
#     end
        
#     def subtractions(value1 , value2)
#         return value1 - value2
#     end
        
#     def multiplications(value1 , value2)
#         return value1 * value2
#     end
    
#     def divisions(value1 , value2)
#         y = value1 / value2
#         x = value1 % value2
        
#         return "division quotient include #{y} , division remainder include #{x}"
#     end
    
# end

# calci = Calculator.new()

# puts calci.additions(30 , 10)
# puts calci.subtractions(30 , 10)
# puts calci.multiplications(30 , 10)
# puts calci.divisions(30 , 10)



#  Write a program for table from 2 to 10

# for i in 2..10
    
#     for j in 1..10
#         puts ("#{i} * #{j} = #{i*j}")
#     end
    
# end


# Write a program to find minimum and maximum between two number

# def MINMAX(value1 , value2)
    
#     if value1 > value2
#         return "value1 i.e #{value1} is maximum"
        
#     elsif value2 > value1
#         return "value2 i.e #{value2} is maximum"
#     end
    
# end


# puts MINMAX(207 , 33)


#  Write a program to find square root of a number given by user


# number = 100

# sqrtno = Math.sqrt(number)

# puts sqrtno


# Write a program to find square and cube of a number given by a user


# class Operations
    
#     def initialize(number)
#         @number = number                 # for instance variable we always use @sign
#     end
    
#     def square
#         return @number*@number
#     end
    
#     def cube
#         return @number**3
#     end

# end

# # values = operations(8)

# operationsValues = Operations.new(8)

# puts operationsValues.square
# puts operationsValues.cube



# Write a program to find minimum and maximum in an array


# arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]

# small = arr[0]
# big = arr[0]

# arr.each do |numbers|
    
#     if small > numbers
#         small = numbers
#         elsif big < numbers
#             big = numbers
#         end
#     end
        
# puts small , big
        
        
# Write a program to find even and odd number in an array

# def calculate(number)
    
#     if number %2 == 0
#         return "even"
#     else return "odd"
#     end
# end

# puts calculate(3)
        
  
# Write a program to find even numbers between 1 to 100

#   for i in 1..100
      
#       if i %2 == 0

#       puts i
#   end

# end        
        

#   Write a program to find odd numbers between 1 to 100

#   for i in 1..100
      
#       if i %2 != 0

#       puts i
#   end

# end      



# Write a program to find factorial of a number enter by user


# def Factorial(number)
    
#     x = 1
#     while number != 0
        
#         x = x * number
#         number = number-1
#     end

# puts x

# end


# Factorial(13)


# Write a program to find sum of digits of a number


# sum = 0
# for i in 1..120
    
#     sum = sum + i
    
# end

# puts sum



# Write a program to find a number is prime or not given by user

# def CheckPrime(number)
    
#     for i in 2..number/2

#       if number % i == 0
        
#         return "not a prime no."
        
#     end
# end

# return "Its a prime no."

# end

# puts CheckPrime(65)



# Write a program to reverse a string given by user

# def reversee(stringvalue)
    
#     x = 0
#     y = stringvalue.length-1        # remember always initiallize values on a diffenent different lines not in one lines
    
#     while x <= y
        
#         temp = stringvalue[x]
#         stringvalue[x] = stringvalue[y]
#         stringvalue[y] = temp
        
#         x = x+1
#         y = y-1
#     end
    
    
#     puts stringvalue

# end

# reversee("chirag")


# Write a program to remove spaces from a string given by user


# def RemoveSpaces( stringValues )
    
#     astr = ""
    
#     stringValues.each_char do |char|                     # for accessing particular character we use .each_char
         
#         if char == " "
#             next
#         elsif astr = astr + char
            
#         end
# end 

# puts astr
# end

# RemoveSpaces("Removc eSpaces djaslhlajoahe")




# Write a program to print pyramid using *
# Note print doesn't go to next line after printing puts 
# goes to next line after printing only puts act's as cout<<endl;

# 5.downto(i)  this line countss in descending order from 5 to i 

# for i in 1..5
    
#     for j in 5.downto(i)
        
#         print " "
#     end

#     for k in 1..(2*i-1)
        
#         print "*"
#     end
#     puts

# end




# Write a program to print inverted pyarmid using *

# for i in 1..5

#   for j in 1..i

#     print " "
    
# end

#  for k in 9.downto(2*i-1)
     
#      print "*"
     
# end

# puts

# end    






# Write a program to sort an array in assecending order

# arr = [2,5,7,4,3,26,7,8]


# for i in 0..arr.length-1

#     for j in i+1..arr.length-1

#       if arr[i] > arr[j]
           
#           temp = arr[j]
#           arr[j] = arr[i]
#           arr[i] = temp
#       end
#   end
# end


# puts arr          # shows every element line by line 
# print arr         # shows every element in single line
    
    
    
    
#  Write a program to find number of vowel in a string


# def vowels(strr)
#     count = 0
    
#      for i in 0..strr.length-1
         
#          if strr[i] == 'a' || strr[i] == 'e' || strr[i] == 'i' || strr[i] == 'o' || strr[i] == 'u' ||
#              strr[i] == 'A' || strr[i] == 'E' || strr[i] == 'I' || strr[i] == 'O' || strr[i] == 'U'  

#          count += 1
#      end
#     end
    
#     print count

# end

# vowels("akhkawkahwebJRLGALALDGALDHGLASHDFL;IAHDLHASDL;HLWEjfiaejrgioharoighaoeirhgoiehrgo;ihawe")




# Write a program to find number of constant in a string
    
    
# def vowels(strr)
#     count = 0
    
#      for i in 0..strr.length-1
         
#          if strr[i] == 'a' || strr[i] == 'e' || strr[i] == 'i' || strr[i] == 'o' || strr[i] == 'u' ||
#              strr[i] == 'A' || strr[i] == 'E' || strr[i] == 'I' || strr[i] == 'O' || strr[i] == 'U'  

#          next
         
#      elsif strr[i] > "A" && strr[i] <= "Z" || strr[i] > "a" && strr[i] <= "z"
#           count +=1
#      end
     
#     end
    
#     print count

# end

# vowels("aeioubnmgughjetd")




# Write a program to count all alphabet in a string

   
#     def vowels(strr)
#     count = 0
    
#      for i in 0..strr.length-1
         
#          if strr[i] >= 'a' && strr[i] <= 'z' || strr[i] >= "A" && strr[i] <= "Z"
#              count += 1
#      end
     
#     end
    
#     print count

# end

# vowels("adsfchbngj8294:::")



# Write a program to add & subtract 10 days in a date

# require 'date'

# day = Date.today - 10

# puts day


# add and subtract one year from a Date

# require 'date'

# day = Date.today - 365

# puts day



#  add and subtract one month from a Date
    
# require 'date'

# day = Date.today - 30

# puts day


# classses and its types 

a = 100

puts a                # 100

b =  a.class  

puts b                # integer

c = b.class

puts c.class          # class






# class Monitor 

#   def webkorps(value1 , value2)
    
#       print value1 , value2
#       puts "Its a method of class monitor"
    
#      return "Hello brother"
   
#  end

#  end


#  class Student < Monitor
   
#     def webkorps
#         super
#         puts "Its a method of class monitor"
#         return super + " my name is chirag"
#     end
# end 



#  monitor = Student.new


# puts monitor.webkorps(3 , 9);



# # monitor = Monitor.new()

# monitor.webkorps(4 ,8)
  
  

# def monitor()
          
#     arr = [1,2,3,4,5,6]
#     arr1 = []
#     i = arr.length-1 
#     k = 0
  
#     for i in 0.downto(arr.length-1)
     
#       arr1[k] = arr[i]
#       k++
     
#     end
#   print arr1      
# end

# monitor()













# Types of variable 

# 5. Variables
# Local variables: name
# Instance variables: @name
# Class variables: @@name
# Global variables: $name

# local variable

# def greetings(name)
#     message = "Hello #{name}"
#     puts message
# end

# greetings("Rohit") # Output: Hello Rohit


# Instance variable

# class Person
#     def initialize(name)
#         @name = name
#     end

#     def greetings
#         puts "Hello #{@name}"
#     end
# end

# person = Person.new("Rohit")
# per son.greetings # Output: Hello Rohit


# class variable

# class Webkorps
    
#     @@count = 0
    
#     def initialize(name)
        
#         @name = name
#         @@count += 1
#     end
    
#     def self.count
#         @@count
#     end
# end

# w1 = Webkorps.new("Chirag")
# w2 = Webkorps.new("varun")


# puts Webkorps.count            # output 2


# global variable

# $counttt
# class Webkorps
    
#     @@count = 0
    
#     def initialize(name)
        
#         @name = name
#         @@count += 1
#         $counttt = @@count
#     end
    
#     # def self.count
#     #     @@count
#     # end
# end

# w1 = Webkorps.new("Chirag")
# w2 = Webkorps.new("varun")


# puts $counttt              # output 2







# shortcut of loop i.e timesloop

# 5.times { |i| puts i }




# Blocks are chunks of code which we right inside {} or do..end that can be passed to a method
# to be executed 

# [1,2,2,3].each do |nums|
#      puts nums
#      end

# or 

# [1,2,33,4].each {|nums| puts nums}


# In the examples above, |num| are block variables, which are placeholders for the values passed into the block.


# yield keyword in ruby

# When a method contains yield, it pauses at that point, and the block of code passed to it is executed. After the block finishes, the method continues running.

# def webkorps 
    
#     puts "Hello mere bahi"
    
#     yield
    
#     print "bro how are you"
#     puts
    
# end

# webkorps {puts "kaisa hai tu"}       


# o/p ->  Hello mere bahi    1st its print and then stop execution and block execution is start and then method continue 
# kaisa hai tu
# bro how are you



# Procs

# A proc is like a block, but it's an object, so you can save it to a variable and reuse it.
# You can pass a proc to a method as an argument.
# Procs are created using Proc.new or the proc method.



# my_Proc = Proc.new { puts "heelo from proc"}    # Here capital P is there 

# my_Proc = proc {puts "Hello baby"}              # Here small p is there

# def greet(prroc)
    
#      prroc.call
# end

# greet(my_Proc)

# output
# puts "heelo from proc
# Hello baby



# procs with different ways

# my_Proc = proc {|name| puts "Hello baby my name is #{name}"}

# my_Proc.call("varun")
# my_Proc.call("Chirag")




# Difference between blocks and procs *********************************************

# Blocks: Simple, can't be stored, and only one per method.
# Procs: Flexible, can be stored in variables, and passed as many times as needed.


# how we can pass block as an argument

# class Greetings
    
#     def greet(name , &block)       #&block reserve keyword used to take block as an argument
        
#         puts  "Hello from #{name}"
        
#         if block_given?        #block_given?  reserve keyword used to check weather
#                                # block passed in a method or not
#             block.call(name)   # its calls the block which is initialize below
#         else
            
#            puts "Hello from greet"
#        end
# end        
    
# end

# greettt = Greetings.new

# greettt.greet("Alice") do |name|       # here we are calling greet method with name and object both 
    
# puts "Hello brother my name is #{name}"
    
# end

# greettt.greet("bob")    # here we calling greet only with name


# output
# Hello from Alice
# Hello brther my name is Alice
# Hello from bob
# Hello from greet


# 2nd way of passing block inside a method 

# class Parent
#   def process(&block)
#     block.call if block_given?
#   end
# end

# class Child < Parent
#   def process(&block)
#     puts "Processing in Child"
#     super
#   end
# end

# child = Child.new
# child.process { puts "Processing in Block" }


# output

# Processing in Child
# Processing in Block




# Lamdbas *****************************************************************************************

# When it comes to encapsulating code into reusable units, lambdas are similar to procs.
#  However, in terms of behavior and syntax, they do differ slightly from one another.
# The main difference lies in argument handling and return statements.


# What are lambdas?
# Lambdas are anonymous functions that can be assigned to variables or passed as arguments.
#  The lambda keyword or the -> syntax is used to define lambdas in Ruby, and behave like methods. 
#  They can be considered as an advanced version of procs.



# my_lambda = lambda { |x, y| x+y}  #using lambda keyword

# my_lambda = ->(x , y) {x + y}    #using -> syntax



# The main difference between lambdas and procs lies in how they handle return statements and argument checking.
# Lambdas perform argument checking, ensuring that correct number of arguments are passed.
# Additionally, lambdas return control to the calling method, whereas procs return immediately, bypassing the calling method


# increment_and_double = ->(num) { (num+1) *2}

# result = increment_and_double.call(5)
# puts "Result = #{result}"


# Notes for procs and lambdas


# Conclusion
# Ruby provides a means to organize statements into blocks of code that can be performed and supplied
#  to functions.

# It is possible to save, call, and send code blocks as parameters to methods by enclosing 
# them in objects called procs in Ruby.

# Using the call method, procs can be called and reused because they can be assigned to variables, 
# making them callable.

# Procs can be supplied to methods as arguments, giving a mechanism to transmit both behavior
#  and data and increasing the flexibility of the code.

# Although lambdas and procs are similar, they differ slightly in their syntax and behavior,
#  including strict parameter checking and method-like return statements.

# Closures, including lambdas and procs, can return values to the calling context using the 
# return keyword, facilitating data exchange between closures and their callers.




# closures*************************************************************************************

# so yield call backs to greeter function and pass greeting  


# Block(Closure): The block { |greet| puts greet + ", World!" } is a closure because it captures 
# the greeting variable from the method's scope and can use it when executed.
 
# def greeter
     
# greeting = "hello"
# yield(greeting)

# end

# greeter do |greet|
# puts greet + ", World!"
# end

# output
# Hello world



# def create_closure
     
# message = "Hello from create closure"

# proc = Proc.new do              # a new proc object which is a closure is created . This proc capture the message variable
#     puts message
# end


# return proc
# end

# create_closure.call

# Output : Hello from create closure

# Closures are blocks, procs, or lambdas that capture the variables from their surrounding context
# (the environment where they were defined).


# They allow you to "freeze" the environment and use it later, even if the environment 
# where the closure was created no longer exists.




# SELF keyword ************************************************************************************

# class Webkorps
    
#     def initialize(name)
#         @name = name
#     end
    
#     def crook
#         puts "my name is #{@name}"
        
#         puts "Hello this is from self #{self}"
#     end
    
# end

# obj1 =  Webkorps.new("Chirag")
# obj2 =  Webkorps.new("varun")

# obj1.crook
# obj2.crook


# here we creating class method i.e. threw self no need to create object when creating method threw self because it's belongs to class method

# class Webkorps
#   def self.greet
#     puts "Hello from the Webkorps class!"
#   end
# end

# Webkorps.greet

# Output:
# Hello from the Webkorps class!


# self is class method when you use self in a class self refer to the class not an instance of a class

# class Webkorps
    
#     def self.discreate           # it's a class method or we can say it's a singleton method 
        
#         puts "Hello from class self #{self}"
#     end
    
# end


# Webkorps.discreate     # it shows the output i.e. Helllo from class self Webkorps




# self used to access instance variable 

# class Webkorps
    
#     def initialize(name)
#         self.name = name                # here self.name= name calling a setter method i.e. name= 
#     end
    
#     def name=(name)                     # this is setter method i.e name=
       
#         @name = name.capitalize            # capitalize used to make first letter of name capital
#     end
    
#     def self_name
#         puts "my name is #{@name}"
   
#    end
# end

# web = Webkorps.new("chirag")
# web.self_name



# self one more e.g

# class Example
#     def self.func
#         puts self.class # Output: class
#     end
# end
  
# Example.func


# an if you see this

# class Example
#     def func
#         puts self.class # Output: Example
#     end
# end
  
# example = Example.new
# example.func



# self Inside of a Class or Module Definition

# Within a class or module definition, self refers to the class or module itself.
#  It allows us to define methods and access class-level variables directly 
#  without the need for a method call.

# No need for method or class call 

# module Webkorps
    
#     puts self       # output Webkorps
    
#     class Employee
#         puts self       #  output Webkorps :: Employee
#     end
    
# end



# Summary:

# self in Instance Methods: Refers to the instance of the class that called the method.
# self in Class Methods: Refers to the class itself.
# Using self to Define Class Methods: You can define a class method using self.method_name.
# Using self to Access Instance Variables: Allows you to call instance methods like setters 
# within other instance methods.


# Singleton method 


# class Webkorps 
#     puts "Hello #{self}"
#     end
    
#     w1 = Webkorps.new
     
#    def w1.func                 # here we are creating threw object memory address 
       
#        puts "hello #{self}"
#    end
   
   
#    w1.func

#   output
# Hello Webkorps
# hello #<Webkorps:0x000064904e064080>       this is object memory address which tells that object is of webkorps class and after that hexadecimal memmory address


# conclusion
# The self variable in Ruby refers to the current object and its behavior depends on the context.

# In a class method, self refers to the class itself. It can be used to define class-level variables
# #  or methods.

# In an instance method, self refers to the instance of the class on which the process is called.
#  It allows accessing and modifying instance-specific data.

# Within a class or module definition, self refers to the class or module itself.
#  It is used to define class/module-level methods and variables.

# In a singleton method, self refers to the singleton object on which the method is defined.
#  Singleton methods are defined on specific instances rather than on the class itself.
# Understanding the different contexts of self is crucial for writing clean and efficient Ruby code as it enables proper utilization of object-oriented concepts and encapsulation.
# By using self-effectively, developers can manipulate and access data at the appropriate level of abstraction, resulting in more maintainable and organized code.





# super keyword **************************************************************

# with arguments
# class Parent
    
#     def initialize(name)
#         @name = name
#     end
# end

# class Child < Parent
    
#     def initialize(name , age)
#         super(name)
#         @age = age
        
#         puts "#{@name}"
#         puts @age
#     end
# end

# childObject = Child.new("Chirag" , 29)



# super keyword without arguments


# no need for an argument to be called threw super class it's automaticallly 
# send child class arguments to base class

# class Parent
    
#     def valueChange(name , age)
#       namevalue = name
#       agevalue = age
       
#       print namevalue ," ", agevalue
#     end
# end

# class Child < Parent
    
#     def valueChange(name , age)
#         super
#     end
# end

# childObject = Child.new

# childObject.valueChange("Chirag" , 29)



# DIffernce between super and super()

# class Parent
#   def foo
#     "Hello from Parent"
#   end

#   def bar(name)
#     "Hello, #{name} from Parent"
#   end
# end

# class Child < Parent
#   def foo
#     super
#   end

#   def bar(name)
#     super()               #always call superclass method without arguments
#   end
# end

# child = Child.new
# puts child.foo # Output: "Hello from Parent"
# puts child.bar("Rahul") # Output: "ERROR"   because when super()  means we call s
# uperclass method without passing any argument even if child class sending 
# any parameter then also super()  didn't call parent with arguments it's always 
# call without arguments 




# exception handling 


# 1st way
# def calculate(a , b)
    
#     begin
    
#     c = a/b
    
#     puts c
    
#    rescue ZeroDivisionError
       
#     puts "caught an exception "
#    end

# end


# calculate(3 , 0)

# 2ND WAY
# def calculate(a , b)
    
#     begin
    
#     c = a/b
    
#     puts c
    
#    rescue ZeroDivisionError
       
#     puts "caught an exception i.e. can't divide by zero"
#    end

# end


# calculate(3 , 0)

# one more way 

# class Parent

#     def foo

#     raise "hello from parent exception"
# end

# end


# class Child < Parent
    
#     def foo
        
#     super 
    
#     puts "this line won't executed because threw super already an exception raise successfully"
    
#     rescue => e
    
#     puts "exception in this code #{e.message}"
    
# end

# end

# child = Child.new

# child.foo




# super with multiple ancestor or we can say in multilevel inheritance 

# class Grandparent
#   def foo
#     "Hello from Grandparent"
#   end
# end

# class Parent < Grandparent
#   def foo
#     super
#   end
# end

# class Child < Parent
#   def foo
#     super
#   end
# end

# child = Child.new
# puts child.foo




# getter and setter ****************************************************************************


# class Webkorps
    
#     attr_accessor :name
    
#     def initialize(name)
#         @name = name
#     end
    
# end

# objext = Webkorps.new("Chirag")

# puts objext.name    # getter 

# objext.name = "alice"


# puts objext.name     # setter


# getter setter second example 

# # class Webkorps
    
# attr_accessor :name    #getter and setter
    
# def name=(value)
    
#     @name = value.capitalize
    
# end

# end

# class Child < Webkorps

# def name=(value)
    
#     super(value)
    
#     puts "Name has been set in the Child class"
    
# end
# end

# objext = Child.new

# objext.name = "john"    # getter 

# puts objext.name

# # objext.name = "alice"

# puts objext.name     # setter



# Files I/O

# replace all things of files threw this two line written below

# File.open("example.txt" , "w") do |file|
#   file.puts "Hello world!"
#   file.puts "This is a file operation in ruby"

# end


# read line by line
# File.open("example.txt" , "r") do |file|
  
#   file.each_line do |line|
#     puts line
#   end

# end

# # appending in a file 

# File.open("example.txt" , "a") do |file|

#   file.puts "This is a file operation append operatinons ruby"

# end

# # r+ shows read and wright 
# File.open("example.txt", "r+") do |file|
#   puts file.read  # Reads the content
#   file.write "Adding new content."  # Writes new content at the end
# end


# # W+ shows  wright and read

# File.open("example.txt", "w+") do |file|
#   file.puts "New content, overwriting the file."
#   file.seek(0)  # Move the file pointer to the beginning
#   puts file.read  # Reads the new content
# end

# # a+ append and read mode

# File.open("example.txt", "a+") do |file|
#   file.puts "Appending this line."
#   file.seek(0)  # Move the file pointer to the beginning
#   puts file.read  # Reads the entire file, including the new content
# end


# # read entire file

# File.open("example.txt", "r") do |file|
#   content = file.read
#   puts content
# end


# # file size

# puts File.size("example.txt")  # Outputs the size of the file in bytes



# # checkking existing file

# if File.exist?("example.txt")
#   puts "File exists."
# else
#   puts "File does not exist."
# end


# Summary:
# Modes: "w", "r", "a", "r+", "w+", "a+".
# Operations: Reading, writing, appending, checking file size, and file existence.
# Examples: Provided for each mode to illustrate typical use cases.






# regualar expression ********************************************************************************

# Regular Expressions are used for matching patterns within strings.

# Ruby provides a powerful set of tools to create and use regex.

# Common methods: =~, .match, .gsub, .scan, etc.

# Application in RoR: Often used in validations, text processing, and data extraction.



# if "hello world" =~ /world/
    
#     puts "found"
    
# else 
#     puts "not found"
# end

# output found


# for case sensitive 

# if "hello World" =~ /world/i
    
#     puts "found"
    
# else 
#     puts "not found"
# end

# found


# matching email formate 

# email = "chirag@gmail.com"

# if email =~ /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
    
#     print "match with email formate"
#     puts
    
# else 
#     puts "not match with email formate"
    
# end



# gsub!  used to replce text

# text = "I love dhruvi"

# text.gsub!("dhruvi" , "anushka")

# puts text


# one more ways of using regular expressin i.e. regex


# (\d+) captures a sequence of digits, and $1 refers to the first captured group (in this case, "123")

# price = "price : $12345"

# if price =~ /price : \$(\d+)/
    
#     puts "the price is #{$1}"       
# end


# output the price is 12345



# Multi threading**************************************************************************************

# Multithreading is a crucial concept in programming that enables the execution of multiple tasks
# concurrently, thereby improving the performance and responsiveness of applications.
# In Ruby, the Thread class provides native support for multithreading,
# allowing developers to leverage the benefits of parallel execution.
# This article aims to delve into the effective usage of Ruby threads,
# providing insights into their creation, termination, lifecycle, exception handling,
# and various other aspects.

# Developers can use Ruby threads to build applications that can handle multiple tasks simultaneously. 
# This is particularly advantageous for tasks that require significant computational power, 
# involve I/O operations, or benefit from concurrent execution for improved performance. 
# Ruby threads provide a higher-level abstraction, making it easier to implement concurrent 
# behaviour and simplifying the development of multi-threaded programs.


# e.g. 1

# thread = Thread.new do   # thread.new keyword is used to create thread
#     puts "helllo woldsdgsdf"
# end


# thread.join  # join keyword is generally used to access thread


# e.g.2

# th1 = Thread.new do 
#     puts "From th1"
# end

# th2 = Thread.new do
#     puts "From th2"
# end

# th1.join
# th2.join

# output  From th1
        # From th2




# Terminating ruby thread 
# Threads in Ruby are terminated automatically when the code within the thread block completes.
#  However, there might be cases where you need to explicitly terminate a thread.
#   The Thread#kill method can be used to forcefully terminate a thread.

# e.g.3

# thread = Thread.new do 
#    puts "hello world"
#    end


# thread.kill
# thread.join
# output   #              -> blank because we kill the thread now after that no sense of join




# Thread Lifecycle


# The lifecycle of a Ruby thread involves the creation, execution, and termination stages.
# During creation, a thread is instantiated using Thread.new and enters the runnable state.
# In the execution stage, the thread actively runs and performs tasks concurrently with other threads.
# It can be paused using Thread#sleep and resumed later. Finally, the thread terminates either 
# by completing its execution or being explicitly terminated using Thread#kill. 
# Managing the thread lifecycle requires synchronization and proper resource management 
# for the stability and integrity of the application.


# Threads and Exceptions


