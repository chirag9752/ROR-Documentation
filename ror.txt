# Write a program to check weather a number is positive, negative or zero



# def check(number)
    
#     if number > 0
#         puts "positive"
        
#     elsif number == 0
#         puts "zero"
        
#     else 
#     puts "negative"
# end
# end

# check(000000)



# Write a program to reverse a number


# def reverse(number)
#     sum = 0
#      while number != 0
         
#          r = number%10
    
#          sum = (sum * 10 + r)
    
#          number = number /10         
#      end
     
#      puts sum
# end


# reverse(123)


# Write a program to check weather a string is palindrome


# def Palindrom(stringvalue)
    
#     i = 0 
#     j = stringvalue.length-1
    
#     while i <= j
        
#         if(stringvalue[i] != stringvalue[j])
#             puts false
#             return
#         end

#         i += 1
#         j -= 1        
        
#     end
    
#     puts true
# end

# Palindrom("AABBAA")
# Palindrom("AAfgsfdse")



# Write a program for calculator having functionality like addition, subtraction, multiplication,
# division showing remainder and quotient  

# class Calculator
    
#     def additions(value1 , value2)
#         return value1 + value2
#     end
        
#     def subtractions(value1 , value2)
#         return value1 - value2
#     end
        
#     def multiplications(value1 , value2)
#         return value1 * value2
#     end
    
#     def divisions(value1 , value2)
#         y = value1 / value2
#         x = value1 % value2
        
#         return "division quotient include #{y} , division remainder include #{x}"
#     end
    
# end

# calci = Calculator.new()

# puts calci.additions(30 , 10)
# puts calci.subtractions(30 , 10)
# puts calci.multiplications(30 , 10)
# puts calci.divisions(30 , 10)



#  Write a program for table from 2 to 10

# for i in 2..10
    
#     for j in 1..10
#         puts ("#{i} * #{j} = #{i*j}")
#     end
    
# end


# Write a program to find minimum and maximum between two number

# def MINMAX(value1 , value2)
    
#     if value1 > value2
#         return "value1 i.e #{value1} is maximum"
        
#     elsif value2 > value1
#         return "value2 i.e #{value2} is maximum"
#     end
    
# end


# puts MINMAX(207 , 33)


#  Write a program to find square root of a number given by user


# number = 100

# sqrtno = Math.sqrt(number)

# puts sqrtno


# Write a program to find square and cube of a number given by a user


# class Operations
    
#     def initialize(number)
#         @number = number                 # for instance variable we always use @sign
#     end
    
#     def square
#         return @number*@number
#     end
    
#     def cube
#         return @number**3
#     end

# end

# # values = operations(8)

# operationsValues = Operations.new(8)

# puts operationsValues.square
# puts operationsValues.cube



# Write a program to find minimum and maximum in an array


# arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]

# small = arr[0]
# big = arr[0]

# arr.each do |numbers|
    
#     if small > numbers
#         small = numbers
#         elsif big < numbers
#             big = numbers
#         end
#     end
        
# puts small , big
        
        
# Write a program to find even and odd number in an array

# def calculate(number)
    
#     if number %2 == 0
#         return "even"
#     else return "odd"
#     end
# end

# puts calculate(3)
        
  
# Write a program to find even numbers between 1 to 100

#   for i in 1..100
      
#       if i %2 == 0

#       puts i
#   end

# end        
        

#   Write a program to find odd numbers between 1 to 100

#   for i in 1..100
      
#       if i %2 != 0

#       puts i
#   end

# end      



# Write a program to find factorial of a number enter by user


# def Factorial(number)
    
#     x = 1
#     while number != 0
        
#         x = x * number
#         number = number-1
#     end

# puts x

# end


# Factorial(13)


# Write a program to find sum of digits of a number


# sum = 0
# for i in 1..120
    
#     sum = sum + i
    
# end

# puts sum



# Write a program to find a number is prime or not given by user

# def CheckPrime(number)
    
#     for i in 2..number/2

#       if number % i == 0
        
#         return "not a prime no."
        
#     end
# end

# return "Its a prime no."

# end

# puts CheckPrime(65)



# Write a program to reverse a string given by user

# def reversee(stringvalue)
    
#     x = 0
#     y = stringvalue.length-1        # remember always initiallize values on a diffenent different lines not in one lines
    
#     while x <= y
        
#         temp = stringvalue[x]
#         stringvalue[x] = stringvalue[y]
#         stringvalue[y] = temp
        
#         x = x+1
#         y = y-1
#     end
    
    
#     puts stringvalue

# end

# reversee("chirag")


# Write a program to remove spaces from a string given by user


# def RemoveSpaces( stringValues )
    
#     astr = ""
    
#     stringValues.each_char do |char|                     # for accessing particular character we use .each_char
         
#         if char == " "
#             next
#         elsif astr = astr + char
            
#         end
# end 

# puts astr
# end

# RemoveSpaces("Removc eSpaces djaslhlajoahe")




# Write a program to print pyramid using *
# Note print doesn't go to next line after printing puts 
# goes to next line after printing only puts act's as cout<<endl;

# 5.downto(i)  this line countss in descending order from 5 to i 

# for i in 1..5
    
#     for j in 5.downto(i)
        
#         print " "
#     end

#     for k in 1..(2*i-1)
        
#         print "*"
#     end
#     puts

# end




# Write a program to print inverted pyarmid using *

# for i in 1..5

#   for j in 1..i

#     print " "
    
# end

#  for k in 9.downto(2*i-1)
     
#      print "*"
     
# end

# puts

# end    






# Write a program to sort an array in assecending order

# arr = [2,5,7,4,3,26,7,8]


# for i in 0..arr.length-1

#     for j in i+1..arr.length-1

#       if arr[i] > arr[j]
           
#           temp = arr[j]
#           arr[j] = arr[i]
#           arr[i] = temp
#       end
#   end
# end


# puts arr          # shows every element line by line 
# print arr         # shows every element in single line
    
    
    
    
#  Write a program to find number of vowel in a string


# def vowels(strr)
#     count = 0
    
#      for i in 0..strr.length-1
         
#          if strr[i] == 'a' || strr[i] == 'e' || strr[i] == 'i' || strr[i] == 'o' || strr[i] == 'u' ||
#              strr[i] == 'A' || strr[i] == 'E' || strr[i] == 'I' || strr[i] == 'O' || strr[i] == 'U'  

#          count += 1
#      end
#     end
    
#     print count

# end

# vowels("akhkawkahwebJRLGALALDGALDHGLASHDFL;IAHDLHASDL;HLWEjfiaejrgioharoighaoeirhgoiehrgo;ihawe")




# Write a program to find number of constant in a string
    
    
# def vowels(strr)
#     count = 0
    
#      for i in 0..strr.length-1
         
#          if strr[i] == 'a' || strr[i] == 'e' || strr[i] == 'i' || strr[i] == 'o' || strr[i] == 'u' ||
#              strr[i] == 'A' || strr[i] == 'E' || strr[i] == 'I' || strr[i] == 'O' || strr[i] == 'U'  

#          next
         
#      elsif strr[i] > "A" && strr[i] <= "Z" || strr[i] > "a" && strr[i] <= "z"
#           count +=1
#      end
     
#     end
    
#     print count

# end

# vowels("aeioubnmgughjetd")




# Write a program to count all alphabet in a string

   
#     def vowels(strr)
#     count = 0
    
#      for i in 0..strr.length-1
         
#          if strr[i] >= 'a' && strr[i] <= 'z' || strr[i] >= "A" && strr[i] <= "Z"
#              count += 1
#      end
     
#     end
    
#     print count

# end

# vowels("adsfchbngj8294:::")



# Write a program to add & subtract 10 days in a date

# require 'date'

# day = Date.today - 10

# puts day


# add and subtract one year from a Date

# require 'date'

# day = Date.today - 365

# puts day



#  add and subtract one month from a Date
    
# require 'date'

# day = Date.today - 30

# puts day


# classses and its types 

a = 100

puts a                # 100

b =  a.class  

puts b                # integer

c = b.class

puts c.class          # class






# class Monitor 

#   def webkorps(value1 , value2)
    
#       print value1 , value2
#       puts "Its a method of class monitor"
    
#      return "Hello brother"
   
#  end

#  end


#  class Student < Monitor
   
#     def webkorps
#         super
#         puts "Its a method of class monitor"
#         return super + " my name is chirag"
#     end
# end 



#  monitor = Student.new


# puts monitor.webkorps(3 , 9);



# # monitor = Monitor.new()

# monitor.webkorps(4 ,8)
  
  

# def monitor()
          
#     arr = [1,2,3,4,5,6]
#     arr1 = []
#     i = arr.length-1 
#     k = 0
  
#     for i in 0.downto(arr.length-1)
     
#       arr1[k] = arr[i]
#       k++
     
#     end
#   print arr1      
# end

# monitor()













# Types of variable 

# 5. Variables
# Local variables: name
# Instance variables: @name
# Class variables: @@name
# Global variables: $name


# shortcut of loop i.e timesloop

# 5.times { |i| puts i }




# Blocks are chunks of code which we right inside {} or do..end that can be passed to a method to be executed 

# [1,2,2,3].each do |nums|
#      puts nums
#      end

# or 

# [1,2,33,4].each {|nums| puts nums}


# In the examples above, |num| are block variables, which are placeholders for the values passed into the block.


# yield keyword in ruby

# When a method contains yield, it pauses at that point, and the block of code passed to it is executed. After the block finishes, the method continues running.

# def webkorps 
    
#     puts "Hello mere bahi"
    
#     yield
    
#     print "bro how are you"
#     puts
    
# end

# webkorps {puts "kaisa hai tu"}       


# o/p ->  Hello mere bahi    1st its print and then stop execution and block execution is start and then method continue 
# kaisa hai tu
# bro how are you



# Procs

# A proc is like a block, but it's an object, so you can save it to a variable and reuse it.
# You can pass a proc to a method as an argument.
# Procs are created using Proc.new or the proc method.



# my_Proc = Proc.new { puts "heelo from proc"}    # Here capital P is there 

# my_Proc = proc {puts "Hello baby"}              # Here small p is there

# def greet(prroc)
    
#      prroc.call
# end

# greet(my_Proc)

# output
# puts "heelo from proc
# Hello baby



# procs with different ways

# my_Proc = proc {|name| puts "Hello baby my name is #{name}"}

# my_Proc.call("varun")
# my_Proc.call("Chirag")




# Difference between blocks and procs *********************************************

# Blocks: Simple, can't be stored, and only one per method.
# Procs: Flexible, can be stored in variables, and passed as many times as needed.


# how we can pass block as an argument

# class Greetings
    
#     def greet(name , &block)       #&block reserve keyword used to take block as an argument
        
#         puts  "Hello from #{name}"
        
#         if block_given?        #block_given?  reserve keyword used to check weather
#                                # block passed in a method or not
#             block.call(name)   # its calls the block which is initialize below
#         else
            
#            puts "Hello from greet"
#        end
# end        
    
# end

# greettt = Greetings.new

# greettt.greet("Alice") do |name|       # here we are calling greet method with name and object both 
    
# puts "Hello brother my name is #{name}"
    
# end

# greettt.greet("bob")    # here we calling greet only with name


# output
# Hello from Alice
# Hello brther my name is Alice
# Hello from bob
# Hello from greet


# 2nd way of passing block inside a method 

# class Parent
#   def process(&block)
#     block.call if block_given?
#   end
# end

# class Child < Parent
#   def process(&block)
#     puts "Processing in Child"
#     super
#   end
# end

# child = Child.new
# child.process { puts "Processing in Block" }


# output

# Processing in Child
# Processing in Block




# Lamdbas *****************************************************************************************

# When it comes to encapsulating code into reusable units, lambdas are similar to procs.
#  However, in terms of behavior and syntax, they do differ slightly from one another.
# The main difference lies in argument handling and return statements.


# What are lambdas?
# Lambdas are anonymous functions that can be assigned to variables or passed as arguments.
#  The lambda keyword or the -> syntax is used to define lambdas in Ruby, and behave like methods. 
#  They can be considered as an advanced version of procs.



# my_lambda = lambda { |x, y| x+y}  #using lambda keyword

# my_lambda = ->(x , y) {x + y}    #using -> syntax



# The main difference between lambdas and procs lies in how they handle return statements and argument checking.
# Lambdas perform argument checking, ensuring that correct number of arguments are passed.
# Additionally, lambdas return control to the calling method, whereas procs return immediately, bypassing the calling method


# increment_and_double = ->(num) { (num+1) *2}

# result = increment_and_double.call(5)
# puts "Result = #{result}"


# Notes for procs and lambdas


# Conclusion
# Ruby provides a means to organize statements into blocks of code that can be performed and supplied
#  to functions.

# It is possible to save, call, and send code blocks as parameters to methods by enclosing 
# them in objects called procs in Ruby.

# Using the call method, procs can be called and reused because they can be assigned to variables, 
# making them callable.

# Procs can be supplied to methods as arguments, giving a mechanism to transmit both behavior
#  and data and increasing the flexibility of the code.

# Although lambdas and procs are similar, they differ slightly in their syntax and behavior,
#  including strict parameter checking and method-like return statements.

# Closures, including lambdas and procs, can return values to the calling context using the 
# return keyword, facilitating data exchange between closures and their callers.




# closures*************************************************************************************

# so yield call backs to greeter function and pass greeting  


# Block(Closure): The block { |greet| puts greet + ", World!" } is a closure because it captures 
# the greeting variable from the method's scope and can use it when executed.
 
# def greeter
     
# greeting = "hello"
# yield(greeting)

# end

# greeter do |greet|
# puts greet + ", World!"
# end

# output
# Hello world



# def create_closure
     
# message = "Hello from create closure"

# proc = Proc.new do              # a new proc object which is a closure is created . This proc capture the message variable
#     puts message
# end


# return proc
# end

# create_closure.call

# Output : Hello from create closure

# Closures are blocks, procs, or lambdas that capture the variables from their surrounding context
# (the environment where they were defined).


# They allow you to "freeze" the environment and use it later, even if the environment 
# where the closure was created no longer exists.





# super keyword **************************************************************

# with arguments
# class Parent
    
#     def initialize(name)
#         @name = name
#     end
# end

# class Child < Parent
    
#     def initialize(name , age)
#         super(name)
#         @age = age
        
#         puts "#{@name}"
#         puts @age
#     end
# end

# childObject = Child.new("Chirag" , 29)



# super keyword without arguments


# no need for an argument to be called threw super class it's automaticallly 
# send child class arguments to base class

# class Parent
    
#     def valueChange(name , age)
#       namevalue = name
#       agevalue = age
       
#       print namevalue ," ", agevalue
#     end
# end

# class Child < Parent
    
#     def valueChange(name , age)
#         super
#     end
# end

# childObject = Child.new

# childObject.valueChange("Chirag" , 29)



# DIffernce between super and super()

# class Parent
#   def foo
#     "Hello from Parent"
#   end

#   def bar(name)
#     "Hello, #{name} from Parent"
#   end
# end

# class Child < Parent
#   def foo
#     super
#   end

#   def bar(name)
#     super()               #always call superclass method without arguments
#   end
# end

# child = Child.new
# puts child.foo # Output: "Hello from Parent"
# puts child.bar("Rahul") # Output: "ERROR"   because when super()  means we call s
# uperclass method without passing any argument even if child class sending 
# any parameter then also super()  didn't call parent with arguments it's always 
# call without arguments 




# exception handling 


# 1st way
# def calculate(a , b)
    
#     begin
    
#     c = a/b
    
#     puts c
    
#    rescue ZeroDivisionError
       
#     puts "caught an exception "
#    end

# end


# calculate(3 , 0)

# 2ND WAY
# def calculate(a , b)
    
#     begin
    
#     c = a/b
    
#     puts c
    
#    rescue ZeroDivisionError
       
#     puts "caught an exception i.e. can't divide by zero"
#    end

# end


# calculate(3 , 0)

# one more way 

# class Parent

#     def foo

#     raise "hello from parent exception"
# end

# end


# class Child  < Parent
    
#     def foo
        
#     super 
    
#     puts "this line won't executed because threw super already an exception raise successfully"
    
#     rescue => e
    
#     puts "exception in this code #{e.message}"
    
# end

# end

# child = Child.new

# child.foo




# super with multiple ancestor or we can say in multilevel inheritance 

# class Grandparent
#   def foo
#     "Hello from Grandparent"
#   end
# end

# class Parent < Grandparent
#   def foo
#     super
#   end
# end

# class Child < Parent
#   def foo
#     super
#   end
# end

# child = Child.new
# puts child.foo




# getter and setter ****************************************************************************


# class Webkorps
    
#     attr_accessor :name
    
#     def initialize(name)
#         @name = name
#     end
    
# end

# objext = Webkorps.new("Chirag")

# puts objext.name    # getter 

# objext.name = "alice"


# puts objext.name     # setter


# getter setter second example 

# # class Webkorps
    
# attr_accessor :name    #getter and setter
    
# def name=(value)
    
#     @name = value.capitalize
    
# end

# end

# class Child < Webkorps

# def name=(value)
    
#     super(value)
    
#     puts "Name has been set in the Child class"
    
# end
# end

# objext = Child.new

# objext.name = "john"    # getter 

# puts objext.name

# # objext.name = "alice"

# puts objext.name     # setter


